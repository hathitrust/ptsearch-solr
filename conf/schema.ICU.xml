<?xml version="1.0" encoding="UTF-8" ?>

<schema name="ICUproduction with Item-level search field" version="1.3">
  <!-- attribute "name" is the name of this schema and is only used for display purposes.
       Applications should change this to reflect the nature of the search collection.
       version="1.2" is Solr's version number for the schema syntax and semantics.  It should
       not normally be changed by applications.
       1.0: multiValued attribute did not exist, all fields are multiValued by nature
       1.1: multiValued attribute introduced, false by default 
       1.2: omitTermFreqAndPositions attribute introduced, true by default except for text fields.
       1.3: removed optional field compress feature
  -->
  
  <types>
    <!-- field type definitions. The "name" attribute is
         just a label to be used by field definitions.  The "class"
         attribute and any other attributes determine the real
         behavior of the fieldType.
         Class names starting with "solr" refer to java classes in the
         org.apache.solr.analysis package.
    -->
    
    <!-- The StrField type is not analyzed, but indexed/stored verbatim. -->
    <fieldType name="string" class="solr.StrField" sortMissingLast="true" omitNorms="true"/>
    
    <!-- boolean type: "true" or "false" -->
    <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true" omitNorms="true"/>
    <!--Binary data type. The data should be sent/retrieved in as Base64 encoded Strings -->
    <fieldtype name="binary" class="solr.BinaryField"/>
    
    
    <!--
        Default numeric field types. For faster range queries, consider the tint/tfloat/tlong/tdouble types.
    -->
    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
    <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
    
    <!--
        Numeric field types that index each value at various levels of precision
        to accelerate range queries when the number of values between the range
        endpoints is large. See the javadoc for NumericRangeQuery for internal
        implementation details.
        
        Smaller precisionStep values (specified in bits) will lead to more tokens
        indexed per value, slightly larger index size, and faster range queries.
        A precisionStep of 0 disables indexing at different precision levels.
    -->
    <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
    <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
    <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
    <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
    
    <fieldType name="date" class="solr.TrieDateField" omitNorms="true" precisionStep="0" positionIncrementGap="0"/>
    
    <!-- A Trie based date field for faster date range queries and date faceting. -->
    <fieldType name="tdate" class="solr.TrieDateField" omitNorms="true" precisionStep="6" positionIncrementGap="0"/>
    
    <fieldType name="sint" class="solr.SortableIntField" sortMissingLast="true" omitNorms="true"/>
    
    <fieldtype  name="ignored" stored="false" multiValued="true" class="solr.StrField"/>
    
    <!-- A text field that only splits on whitespace for exact matching of words -->
    <fieldType name="text_ws" class="solr.TextField" positionIncrementGap="100">
      <analyzer>
        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
      </analyzer>
    </fieldType>
    
    
    <!-- ########################################################### -->
    <!-- ##########  M B o o k s   F i e l d   T y p e s  ########## -->
    <!-- ########################################################### -->
    
    
    <!-- use this instead of mbooksOcrXpatLike.  Better handling of multilingual-->
    <fieldType name="mbooksRegular" class="solr.TextField" positionIncrementGap="100">
      <analyzer>
        <tokenizer class="solr.ICUTokenizerFactory"/>
        <filter class="solr.ICUFoldingFilterFactory"/>
      </analyzer>
    </fieldType>  
    
    <!-- norms are omitted so short pages do not score higher than long pages with same number of matches -->
    <fieldType name="FullText" class="solr.TextField" positionIncrementGap="100" autoGeneratePhraseQueries="false" stored="true" termVectors="true" termPositions="true" termOffsets="true" omitNorms="true">
      <analyzer type="index">
        <tokenizer class="solr.ICUTokenizerFactory"/>
        <filter class="solr.ICUFoldingFilterFactory"/>
        <filter class="solr.CommonGramsFilterFactory" words="1000common.txt" />
      </analyzer>
      <analyzer type="query">
        <tokenizer class="solr.ICUTokenizerFactory"/>
        <filter class="solr.ICUFoldingFilterFactory"/>
        <filter class="solr.CommonGramsQueryFilterFactory" words="1000common.txt" />
      </analyzer>
    </fieldType>  
    
    
    
    <!--################################## VuFind types #######################################-->
    <!-- translated to Solr-->
    
    <!-- XXX todo, see if we can do normalization, then wdf then folding as
         wdf needs the caps! -->
    
    <!-- Standard Text Field  with porter English stemming -->
    <fieldtype name="text" class="solr.TextField" positionIncrementGap="100">
      <analyzer type="index">
        <tokenizer class="solr.ICUTokenizerFactory"/>
        <filter class="solr.ICUFoldingFilterFactory"/>
        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
        <filter class="solr.EnglishPorterFilterFactory" protected="protwords.txt"/>
        <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
      </analyzer>
      <analyzer type="query">
        <tokenizer class="solr.ICUTokenizerFactory"/>
        <filter class="solr.ICUFoldingFilterFactory"/>
        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
        <filter class="solr.EnglishPorterFilterFactory" protected="protwords.txt"/>
        <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
      </analyzer>
    </fieldtype>
    
  </types>
  
  
  <fields>
    <!-- Valid attributes for fields:
         name: mandatory - the name for the field
         type: mandatory - the name of a previously defined type from the 
         <types> section
         indexed: true if this field should be indexed (searchable or sortable)
         stored: true if this field should be retrievable
         multiValued: true if this field may contain multiple values per document
         omitNorms: (expert) set to true to omit the norms associated with
         this field (this disables length normalization and index-time
         boosting for the field, and saves some memory).  Only full-text
         fields or fields that need an index-time boost need norms.
         termVectors: [false] set to true to store the term vector for a
         given field.
         When using MoreLikeThis, fields used for similarity should be
         stored for best performance.
         termPositions: Store position information with the term vector.  
         This will increase storage costs.
         termOffsets: Store offset information with the term vector. This 
         will increase storage costs.
         default: a value that should be used if no value is specified
         when adding a document.
    -->
    
    
    <!-- ################################################### -->
    <!-- #            M B o o k s   F i e l d s            # -->
    <!-- ################################################### -->
    
    <!-- mdp.390151234567890 -->
    
    <!-- Volume ID field-->
    <field name="vol_id"    type="string"        indexed="true" stored="true" multiValued="false" required="true"/>
    <!-- To avoid conflict with vufind 'id' field -->
    <field name="hid"       type="string"        indexed="true" stored="true" multiValued="false" required="true"/>
    <field name="seq"       type="int"           indexed="true" stored="true" multiValued="false" required="true"/>
    <field name="pgnum"     type="string"        indexed="true" stored="true" multiValued="false" required="false"/>
    <field name="ocr"       type="FullText"      indexed="true" stored="true" multiValued="false" required="true"/>
    
    
    <field name="title"     type="mbooksRegular" indexed="true" stored="true" multiValued="true"  required="true"/>
    <field name="rights"    type="sint"          indexed="true" stored="true" multiValued="false" required="true"/>
    <field name="author"    type="mbooksRegular" indexed="true" stored="true" multiValued="true"  required="false"/>
    <field name="date"      type="string"        indexed="true" stored="true" multiValued="true"  required="false"/>
    
    <field name="timestamp" type="date"          indexed="true" stored="true" default="NOW" multiValued="false"/>
    
    <!-- ##################################################### -->
    <!-- #         V u F i n d   F i e l d s                 # -->
    <!-- ##################################################### -->
    <!-- Core Fields  -->
    <!-- VuFind id field mapped to record_no in processing -->
    <field name="record_no" type="string"        indexed="true" stored="true"/>   
    
    
    <!-- Dynamic field definitions.  If a field name is not found, dynamicFields
         will be used if the name matches any of the patterns.
         RESTRICTION: the glob-like pattern in the name attribute must have
         a "*" only at the start or the end.
         EXAMPLE:  name="*_i" will match any field ending in _i (like myid_i, z_i)
         Longer patterns will be matched first.  if equal size patterns
         both match, the first appearing in the schema will be used.  -->
    
    <!-- Mbooks dynamic field-->
    <dynamicField name="*_ft"  type="FullText" indexed="true"  stored="true"/>
    
    <dynamicField name="*_i"  type="int"     indexed="true"  stored="true"/>
    <dynamicField name="*_s"  type="string"  indexed="true"  stored="true"/>
    <dynamicField name="*_l"  type="long"    indexed="true"  stored="true"/>
    <dynamicField name="*_t"  type="text"    indexed="true"  stored="true"/>
    <dynamicField name="*_b"  type="boolean" indexed="true"  stored="true"/>
    <dynamicField name="*_f"  type="float"   indexed="true"  stored="true"/>
    <dynamicField name="*_d"  type="double"  indexed="true"  stored="true"/>
    
    <dynamicField name="*_dt" type="date"    indexed="true"  stored="true"/>
    
    
    <!-- some trie-coded dynamic fields for faster range queries -->
    <dynamicField name="*_ti"  type="tint"    indexed="true"  stored="true"/>
    <dynamicField name="*_tl"  type="tlong"   indexed="true"  stored="true"/>
    <dynamicField name="*_tf"  type="tfloat"  indexed="true"  stored="true"/>
    <dynamicField name="*_td"  type="tdouble" indexed="true"  stored="true"/>
    <dynamicField name="*_tdt" type="tdate"   indexed="true"  stored="true"/>
    
    <dynamicField name="ignored_*" type="ignored" multiValued="true"/>
    
    
    <!-- uncomment the following to ignore any fields that don't already match an existing 
         field name or dynamic field, rather than reporting them as an error. 
         alternately, change the type="ignored" to some other type e.g. "text" if you want 
         unknown fields indexed and/or stored by default --> 
    <!--dynamicField name="*" type="ignored" multiValued="true" /-->
    
  </fields>
  
  <!-- Field to use to determine and enforce document uniqueness. 
       Unless this field is marked with required="false", it will be a required field
  -->
  <uniqueKey>hid</uniqueKey>
  
  <!-- field for the QueryParser to use when an explicit fieldname is absent -->
  <defaultSearchField>ocr</defaultSearchField>
  
  <!-- SolrQueryParser configuration: defaultOperator="AND|OR" -->
  <solrQueryParser defaultOperator="OR"/>
  
</schema>
